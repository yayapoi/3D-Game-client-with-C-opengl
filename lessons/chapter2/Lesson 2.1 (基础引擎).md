在上一章中，你学习了从零开始构建游戏的基础知识。你创建了一个简单的游戏，该游戏能响应键盘输入，播放基本动画，并显示一些文本。太棒了

在本章中，我们将基于你迄今为止所学的知识，开始构建一个真正的游戏引擎。换言之，我们将开始将你现有的代码和经验整合到一个实际的游戏引擎基础中，这个引擎可用于未来的游戏开发。

我们将从大多数引擎开发者的起点开始—— **主游戏循环** 。

为了实现它，我们需要操作两个关键实体：

1. **Engine** – 这是整个游戏引擎的基类。它将负责初始化、更新和清理工作。本质上，这将是引擎的主要控制器。

2. **Application** (or **Game**) – 这是你作为开发者将直接与之交互的类。在下一章中，我们将深入探讨如何构建这个类。我选择称之为`Application`而不是`Game`，因为我们正在构建的引擎不仅可以用于游戏，还可以用于其他类型的交互式软件，如演示、模拟等。

### 基本结构

`Engine` 类将包含三个核心函数：

* `Init()`
* `Run()`
* `Destroy()`

在内部，该引擎将保存一个`Application`类的实例。在其每个方法中，它将调用`Application`中的相应方法。例如：

* `Engine::Init()` 将调用 `Application::Init()`
* `Engine::Destroy()` 将调用 `Application::Destroy()`

`Run()` 方法是实际游戏循环发生的地方。在该方法内部，我们将使用一个 `while` 循环来计算时间差，并调用类似 `m_application.Update(deltaTime)` 的函数。

既然我们现在正在着手实现一个实际的引擎，那么是时候把它拆分成一个单独的模块了。

### 项目结构

让我们做以下事情：

1. 在你的源代码根目录下，新建一个名为`engine`的文件夹。
2. 在`engine`目录下，创建一个名为`source`的文件夹。
3. 在`source`文件夹中，创建以下文件：

   * `Engine.h`, `Engine.cpp`
   * `Application.h`, `Application.cpp`

此外，在`engine`文件夹中，创建一个`CMakeLists.txt`文件来定义引擎模块。将项目命名为`project(Engine)`，并包含我们刚刚创建的源文件。别忘了像我们在游戏项目中那样，将`include_directories`设置为`source`。

与游戏可执行文件不同，我们将把引擎编译为 **库** ，而非可执行文件。因此，我们将使用`add_library`而不是`add_executable`。

接下来，回到游戏的主CMakeLists文件，并移除对 GLFW 和 GLAD 的直接依赖。现在，这些库应该通过引擎模块被包含进来，这样用户就不必直接处理它们了。

然后，将这些第三方库的实际源代码（`thirdparty` 文件夹）移至 `engine` 目录中。确保引擎模块能够链接到它们。

### 最后步骤

现在我们的引擎已经打包成一个合适的模块。我们可以通过链接到`engine`库，在主游戏代码中开始使用它，就像我们之前链接到GLFW或GLTF一样。  

让我们重新生成项目，重新加载它，然后尝试编译。  

太棒了 —— 项目成功编译。我们的引擎基础已经就绪。让我们继续前进！