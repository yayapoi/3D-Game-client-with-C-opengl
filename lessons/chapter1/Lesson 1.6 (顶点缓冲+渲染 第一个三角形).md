太棒了 现在我们需要将三角形数据——具体来说是顶点数据——上传到GPU内存中。在OpenGL中，这是通过缓冲区来实现的。

要创建缓冲区，我们调用 `glGenBuffers` 函数，并传入一个变量的引用，该变量通常命名为 `vbo` 。缓冲区生成后，我们需要通过调用 `glBindBuffer` 并指定 `GL_ARRAY_BUFFER` 目标来使其处于活动状态。 `GL_ARRAY_BUFFER` 参数表示此缓冲区将存储一个顶点数据数组。

既然缓冲区已经激活，我们就可以将顶点数据从系统内存传输到GPU内存了。这是通过使用函数 `glBufferData` 来完成的。该函数接受以下参数：

1. 目标缓冲区类型 — 在我们的例子中，是 `GL_ARRAY_BUFFER`。
2. 我们想要传输的数据大小——通常为 `verticesSize * sizeof(float)`.
3. 一个指向我们数据起始位置的指针。
4. 使用模式——在我们的例子中，是 `GL_STATIC_DRAW` 。这表示数据将只上传一次且不会更改，因此它将永久保留在GPU内存中。

太好了。数据现在已经上传了。我们可以通过再次调用 `glBindBuffer` 函数，并使用相同的目标 `GL_ARRAY_BUFFER`，同时传递 `0` 作为缓冲区ID，来解除缓冲区的绑定。

现在顶点数据驻留在GPU内存中。

接下来，我们需要告诉图形流水线，或者更准确地说，是我们的着色器程序，在数据到达顶点着色器时如何解释这些数据。

OpenGL 提供了一个名为 **顶点数组对象 (VAOs)** 的概念。VAO 存储了顶点属性在缓冲区中的布局方式以及它们如何映射到着色器输入的配置信息。

让我们创建一个顶点数组对象（VAO）。这可以通过使用函数 `glGenVertexArrays` 来完成。创建完成后，我们需要使用 `glBindVertexArray` 来激活它。

现在VAO已激活。

下一步是绑定我们之前上传数据的缓冲区。我们通过调用 `glBindBuffer(GL_ARRAY_BUFFER, vbo)` 来实现这一点。这告诉OpenGL，在当前绑定的顶点数组对象（VAO）中，我们希望将这个缓冲区关联为顶点数据的来源。

接下来，我们将详细说明如何解释缓冲区中的数据。这是通过函数 `vertexAttribPointer` 来完成的。

参数的工作原理如下：

1. 顶点着色器所期望的 **属性索引** 。如果你还记得着色器代码，我们在位置0定义了位置，所以我们使用索引0。
2. 每个属性的 **组件数量** 。对于位置，我们使用 `x`、`y`和`z`，所以是3个。
3. **数据类型** — 在我们的例子中，是 `GL_FLOAT`。
4. 数据是否应进行 **归一化** 处理——我们将其设置为 `GL_FALSE`，因为我们的数据已经符合所需的格式。
5. **步幅**（stride）——这是一个顶点所有属性的总字节数。由于每个顶点仅包含一个位置（3个浮点数），因此步幅为`3 * sizeof(float)`。
6. **偏移量** — 这告诉OpenGL从哪里开始读取数据。由于我们只传递位置数据，并且是从开始处开始，所以我们传递 `(void*)0`。

在指定了如何读取数据之后，我们使用 `glEnableVertexAttribArray` 启用属性数组，并传入相同的索引（0）。

太棒了 现在着色器知道如何访问顶点数据了。

我们现在可以用 `glBindBuffer(GL_ARRAY_BUFFER, 0)` 来解除缓冲区的绑定，同时通过调用 `glBindVertexArray(0)` 来解除顶点数组对象（VAO）的绑定。

现在，我们的顶点数据已经完全配置好，可以开始绘制了。

接下来，我们来看渲染循环。在`while`循环内部，调用`glClear`之后，我们会执行以下操作：

1. 使用 `glUseProgram(shaderProgram)` 来激活我们的着色器程序。
2. 使用 `glBindVertexArray` 函数绑定包含我们顶点数据布局的顶点数组对象（VAO）。

现在一切就绪，可以开始画了。

为了渲染三角形，我们调用 `glDrawArrays` 。其参数为：

1. **基本类型** — `GL_TRIANGLES`，因为我们正在绘制一个三角形。
2. 缓冲区中的**起始顶点**——我们从0开始。
3. **顶点数量** — 由于我们正在绘制一个三角形，所以使用3。

```cpp
glDrawArrays(GL_TRIANGLES, 0, 3);
```

太好了！ 运行你的应用程序，如果一切操作都正确的话…

**恭喜你渲染出了第一个三角形！**
