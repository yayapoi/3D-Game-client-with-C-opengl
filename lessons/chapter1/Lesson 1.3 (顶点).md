所有使用现代图形应用程序编程接口（API）渲染的对象都存在于三维空间中。因此，每个对象在该空间中都有其自己的位置，该位置由三个坐标轴定义：X、Y和Z。

有两种不同的坐标系：右手坐标系和左手坐标系。它们有什么区别呢？区别就在它们的命名上。在 **右手坐标系** 中，如果你将右手的拇指指向X轴方向，食指指向Y轴方向，那么你的中指（与两者垂直）将指向Z轴方向。在这种情况下，Z轴 **指向你** ，即指向屏幕外。

在 **左手系** 中，若以相同方式使用左手，则Z轴将 **指向远离你的方向** ，即指向屏幕内。

场景中的所有模型都由构成网格的基元对象组成。这些基元是多边形，最常见的是三角形。因此，任何3D模型都可以表示为在空间中排列的三角形集合。

为了理解渲染的工作原理，我们将从一个简单的三角形开始——它是计算机图形学的 “Hello World”。

我们还应该提及**归一化设备坐标（NDC）**的概念。屏幕有自己的坐标系，其中X、Y和Z值的范围为-1到1。

每个多边形都由其顶点定义。三角形有三个顶点。因此，要定义一个三角形，我们需要指定其三个顶点的坐标。在我们的示例中：

* 第一个 vertex: (0, 0.5)
* 第二个 vertex: (-0.5, -0.5)
* 第三个 vertex: (0.5, -0.5)

我们在此省略了Z坐标，假设所有点都位于Z=0处——即屏幕平面。

值得注意的是，顶点的 **绕组顺序** 很重要。像OpenGL这样的图形应用程序编程接口（API）默认使用 **逆时针（CCW）** 绕组。这意味着，当按给定顺序连接顶点时，它们应形成一个“朝前”的三角形。

因此，正确的顶点顺序为：

1. (0.0f, 0.5f, 0.0f)
2. (-0.5f, -0.5f, 0.0f)
3. (0.5f, -0.5f, 0.0f)

现在，让我们来创建表示三角形的数据结构。我们将使用 `std::vector<float>` 来存储顶点坐标：

```cpp
#include <vector>

std::vector<float> triangleVertices = 
{
    0.0f,  0.5f, 0.0f,
   -0.5f, -0.5f, 0.0f,
    0.5f, -0.5f, 0.0f
};
```

恭喜！我们已经描述了第一个三角形，并准备好了渲染所需的数据。

