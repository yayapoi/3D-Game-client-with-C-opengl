### 简介
我为你设计了这个游戏，以证明你已经能够将新学到的知识付诸实践。
让我们深入了解一下我们游戏的代码——经典的贪吃蛇游戏！你可能知道游戏规则：蛇使用箭头键（左、右、上、下）在场地中移动，收集水果（或浆果，或点），每收集一个水果就增长一段长度。如果蛇撞到墙壁或自己身上——游戏结束。每隔几个水果，游戏速度就会加快一点。得分高者获胜！

所有内容都已涵盖——移动、得分追踪、水果收集、碰撞检测以及游戏重启。接下来，我们将详细了解这些功能在代码中是如何实现的。

---

### 头文件

在顶部，我们包含了标准库：

* OpenGL头文件：`<glad/glad.h>`，`<GLFW/glfw3.h>`
* 标准C++库中的实用程序，如 `<vector>`, `<random>`, `<chrono>`, `<map>`, `<string>`, `<iostream>`

---

### 数据结构

我们定义了三个自定义结构体：

* `Vec2` — 使用浮点数存储二维位置。适用于发送给着色器的屏幕空间位置。
* `Vec2i` — 整数网格坐标。游戏场是一个网格，这个结构体代表每个单元格。
* `Vec3` — 用于存储RGB颜色值（红、绿、蓝）。

---

### 游戏常量

我们定义：

* 水平和垂直方向的网格单元数量。
* 蛇的移动速度（`UPDATE_INTERVAL`）。
* 用于将网格转换为屏幕空间的单元尺寸。

---

### 游戏状态变量

这些会追踪游戏的所有相关信息：

* 蛇身（`std::vector<Vec2i>`）、方向（`enum class Direction`）、分数、水果位置，以及表示游戏是否已开始或结束的标志。
* 还有一个时间累加器来控制移动速度。

---

### 着色器代码

我们使用两个着色器：

* **Vertex shader（顶点着色器）:** 接收正方形的坐标，并应用`uOffset`和`uScale`来正确地将它们定位在屏幕上。
* **Fragment shader（片断着色器）:** 使用作为`uColor`统一变量传递的纯色填充正方形

这些着色器极其简单，非常适合基于网格的游戏。

---

### OpenGL变量

我们准备OpenGL对象：

* 用于绘制四边形的VAO和VBO。
* 我们着色器统一变量的位置。
* 着色器程序ID。

---

### 位图字体系统

文本是通过将字母绘制成5x5像素网格来显示的。每个字符都定义在一个`std::map<char, std::vector<int>>`中，其中1表示填充单元格，0表示透明。

* 这使得我们能够使用与游戏其他部分相同的网格逻辑来绘制字母和数字。
* 绘图函数遍历这些数据，并逐像素渲染每个字符。

---

### 游戏初始化

* `InitGame()` 函数会调用 `ResetGame()` 和 `SpawnFruit()` 函数。
* `ResetGame()` 函数用于设置蛇的初始位置，并重置分数、标记和计时器。
* `SpawnFruit()` 函数会随机选择一个未被蛇占据的单元格。

这确保了每次都能有一个全新的开始。

---

### 主游戏循环

在`main()`函数中发现：

1. 我们计算帧之间的 `deltaTime`。
2. 我们使用 `glfwPollEvents()` 来处理输入。
3. 我们通过调用 `UpdateGame(deltaTime)` 来更新游戏逻辑。
4. 我们使用 `RenderGame(window)` 来绘制所有内容。

循环持续，直至窗口关闭。

---

### 游戏更新逻辑

在 `UpdateGame()` 函数内部：

* 如果比赛已经开始且尚未结束，我们就会累积时间。
* 等到时间足够长，我们再移动蛇。
* 我们根据方向计算出一个新的头部位置。
* 如果蛇碰到墙壁或自身身体，游戏结束。
* 如果它吃了一个水果：

  * 我们将分数提高了10分。
  * 添加一种新水果。
  * 每收集5个水果（50分），我们就会让蛇移动得更快。
* 如果没吃果实，我们就把最后一段尾巴剪掉。

---

### 渲染过程

`RenderGame()` 函数负责处理所有绘图操作：

1. 用深色背景清空屏幕。
2. 使用我们的着色器程序。
3. 绑定VAO。
4. 调用 `DrawBorder()` 函数来绘制边框和背景网格。

然后:

* 如果游戏尚未开始：`DrawStartScreen()`（标题 + 说明）。
* 如果游戏结束：`DrawGameOver()`（显示覆盖图、分数、重新开始提示）。
* 否则：绘制蛇和得分。

---

### 绘图函数

* `DrawCell(position, color)` — 绘制单个网格单元格。
* `DrawSnake()` — 绘制每个蛇段，蛇头为亮绿色，蛇身颜色较深，带有渐变效果。
* `DrawScore()` — 在顶部显示分数文本。
* `DrawBorder()` — 绘制外框和棋盘背景。
* `DrawStartScreen()` — 显示标题和说明。
* `DrawGameOver()` — 显示半透明的覆盖层和重新开始提示。

---

### 键盘输入

由`KeyCallback()`处理：

* 游戏开始前：任意键启动游戏并向右移动。
* 如果游戏结束且按下 `R` 键：重置游戏并生成水果。
* 游戏过程中：使用箭头键改变方向（无直接反转）。

此函数已在GLFW中注册，并在发生按键事件时自动触发。

---

### 清理

当玩家关闭窗口时：

* 我们删除VAO、VBO和着色器程序。
* 然后我们终止GLFW。

这是释放GPU和系统内存的良好做法。

---

### 摘要

我们刚刚讲解了游戏的核心组件 —— 从渲染和输入处理到游戏循环和状态更新。现在，你可以运用所学知识，独立实现所有这些功能。恭喜你从零开始构建了你的第一个游戏！前方还有更多内容等待你去探索。