让我们回忆一下之前是如何将场景视为一种空间的。在我们的例子中，我们将其想象为一座房子或一个大房间，里面摆放着各种物品。你明白这些物品是放置在那个房间里的 —— 它们被带入并放置在特定的位置。本质上，它们是在一个特定的位置“诞生”的 —— 零点，即房间的中心或房子的中心，世界的中心。

但如果我们将所有物体都放置在这个唯一的原点上，它们就会相互重叠，结果在视觉上将毫无意义。相反，我们想要的是能够将它们从一个位置移动到另一个位置，在空间中旋转它们，甚至改变它们的大小。这正是我们使用 **变换** 的原因。

那么，什么是 **变换** 呢？

一个变换只是三个主要属性的组合：

1. **Position 位置** – 这定义了物体在空间中的具体位置。利用它，我们可以将物体移动到不同的位置。

2. **Rotation 旋转** – 这定义了对象在空间中的方向，即它相对于X、Y和Z轴的旋转方式。

3. **Scale 缩放** – 这定义了对象的大小。它告诉我们对象是放大了、缩小了，还是保持了原始大小。

但有趣的部分 —— 或者说挑战 —— 在于：计算机并不理解像“移动”、“旋转”或“缩放”这样的词汇。它需要的是简单的数字，而且不仅仅是数字——这些数字必须以非常特定的方式组织。

这就是 **矩阵** 发挥作用的地方。

### 什么是矩阵？

矩阵只是一张数字表格。例如，这是一个3×3的单位矩阵：

```
1 0 0  
0 1 0  
0 0 1
```

如果你从左上角对角线看向右下角，你会发现所有这些对角线元素都等于1 —— 这就是为什么它被称为“单位”矩阵。应用该矩阵时，它根本不会改变对象。

但是一旦我们开始改变矩阵中的值，它就会以不同的方式影响物体 —— 移动、旋转或缩放物体。

目前，我们不会深入探讨其背后的数学原理。重要的是要理解：矩阵使我们能够以计算机能够理解的方式 *结合* 和 *表达* 我们的变换 —— 位置、旋转和缩放。

在3D（三维）环境中，我们使用 **4×4矩阵** 来进行这些变换。这种大小是必要的，因为它允许我们将所有三种操作（平移、旋转、缩放）组合成一个矩阵，并一次性应用它们。

### 它是如何工作的？

假设我们有一个对象。我们想对其应用位置、旋转和缩放。

我们从创建一个单位矩阵开始 —— 这是一个“中性”矩阵，没有任何作用。

然后，我们逐步向其中添加转换：

1. 首先，我们使用以下函数进行**translation**：

   ```cpp
   model = glm::translate(model, position);
   ```

2. 接下来，我们添加 **旋转** 功能，该功能允许我们围绕特定轴将对象旋转一定角度。

3. 最后，我们添加了 **缩放** 功能，以沿X、Y和Z轴调整对象的大小。

通过依次组合这三种变换，我们得到了所谓的 **模型矩阵**（有时也称为**世界矩阵**）。该矩阵描述了如何将对象从其 **局部空间**（即其自身原点）转换到 **世界空间**（即整个场景）。

这就像手里拿着一个立方体 —— 首先你旋转它，然后向左移动。这一系列动作与应用多个变换相同。而矩阵只是用数字记录这些步骤的一种方式。

### 在我们的项目中运用转换

让我们尝试将这一概念应用于我们当前的游戏项目中。

为了让矩阵操作更加便捷，我们将使用标准的 **GLM库**（OpenGL Mathematics）。你可以在本视频附带的资源中找到相关代码和设置说明。

GLM使我们能够执行我们现在正在讨论的以及将来会继续使用的所有基本3D变换。它还与我们的渲染API完美集成——记住，我们使用 **OpenGL**将所有渲染数据发送到GPU。

### 实施时间

为了将变换功能集成到我们的游戏中，我们将深入探讨`GameObject`类。

是时候开始使用变换了。